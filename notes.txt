HTML → define <div>s for table, hands, scores, and card elements.

CSS → make cards look like cards, position players around the table.

JS → add event handlers for clicks, basic DOM updates.

Server → Node.js + socket.io for real-time communication.

Django (Python)	Node.js / Express (JS)
views.py	server.js
def my_view(request)	app.get('/route', (req, res) => { ... })
render(request, "template.html", context)	res.sendFile("index.html") or res.json({...})
URL routing (urls.py)	app.get/post/put('/path', handler)

import express from "express";
const app = express();

app.get("/", (req, res) => {
  res.sendFile(__dirname + "/public/index.html");  // serve frontend
});

app.listen(3000, () => console.log("Server running on port 3000"));

import express from "express";
import { createServer } from "http";
import { Server } from "socket.io";

const app = express();
const server = createServer(app);
const io = new Server(server);

app.use(express.static("public")); // serve frontend

io.on("connection", (socket) => {
  console.log("A player connected");

  socket.on("playCard", (card) => {
    io.emit("cardPlayed", card); // send to all players
  });
});

server.listen(3000, () => console.log("Server running on port 3000"));

Player clicks card (event handler) 
    ↓
JS emits WebSocket message → server
    ↓
Server updates game state, broadcasts → all clients
    ↓
Each client’s JS receives update → updates DOM/UI
💡 Analogy:

Click handlers = “I want to play this card”

WebSocket = “Tell the game server”

Server broadcast = “Tell all players what card was played”

Receiving client handlers = “Update the table visually”